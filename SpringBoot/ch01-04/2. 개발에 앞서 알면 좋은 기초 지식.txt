2.1 서버 간 통신
  마이크로서비스 아키텍처(MSA): 서비스 규모를 작게 나누어 구성한 아키텍처
  애플리케이션 하나에 여러 기능을 넣어 개발하지 않고, 애플리케이션을 기능별로 나눠서 개발
  서버 간 통신: 한 서버가 다른 서버에 통신을 요청하는 것. 한 대는 서버, 다른 한 대는 클라이언트가 되는 구조.
                가장 많이 사용되는 방식 - HTTP/HTTPS

2.2 스프링 부트의 동작 방식
  spring-boot-starter-web 모듈 사용 -> 기본적으로 톰캣을 사용하는 스프링 MVC 구조 기반 동작
  
  서블릿: 클라이언트의 요청을 처리하고 결과를 반환하는 자바 웹 프로그래밍 기술. 서블릿 컨테이너에서 관리
  서블릿 컨테이너: 서블릿 인스턴스 생성, 관리
  톰캣: WAS의 역할과 서블릿 컨테이너의 역할을 수행하는 대표적인 컨테이너

  서블릿 컨테이너 특징
  * 서블릿 객체를 생성, 초기화, 호출, 종료하는 생명주기 관리
  * 서블릿 객체는 싱글톤 패턴으로 관리
  * 멀티 스레딩 지원

  스프링에서는 DispatchServlet이 서블릿의 역할 수행
  (1) DispatchServlet으로 요청(HttpServletRequest)이 들어오면, DispatchServlet은 핸들러 매핑을 통해 요청 URI에 매핑된 핸들러(Controller) 탐색
  (2) 핸들러 어댑터로 컨트롤러 호출
  (3) 핸들러 어댑터에 컨트롤러의 응답이 돌아오면 ModelAndView로 응답을 가공해 반환
  (4) 뷰 형식으로 리턴하는 컨트롤러를 사용할 때는 뷰 리졸버를 통해 뷰를 받아 리턴

  핸들러 매핑: 요청 정보를 기준으로 어떤 컨트롤러를 사용할지 선정하는 인터페이스
  * BeanNameUrlHandlerMapping
    빈 이름을 URL로 사용하는 매핑 전략.
    빈을 정의할 때 슬래시('/')가 들어가면 매핑 대상
    ex- @Bean("/hello")
  * ControllerClassNameHandlerMapping
    URL과 일치하는 클래스 이름을 갖는 빈을 컨트롤러로 사용하는 전략.
    이름 중 Controller를 제외하고 앞부분에 작성된 suffix를 소문자로 매핑
  * SimpleUrlHandlerMapping
    URL 패턴에 매핑된 컨트롤러를 사용하는 전략
  * DefaultAnnotationHandlerMapping
    어노테이션으로 URL과 컨트롤러를 매핑하는 방법

2.3 레이어드 아키텍처
  애플리케이션의 컴포넌트를 유사 관심사를 기준으로 레이어로 묶어 수평적으로 구성한 구조.
  일반적으로 3계층 또는 4계층(인프라(데이터베이스) 레이어의 추가 여부)
  
  * 프레젠테이션 계층
    애플리케이션의 최상단 계층. 클라이언트의 요청을 해석하고 응답
    UI나 API 제공
    별도의 비즈니스 로직 포함X, 비즈니스 계층으로 요청을 위임하고 받은 결과를 응답하는 역할만 수행
  * 비즈니스 계층
    애플리케이션이 제공하는 기능 정의, 세부 작업을 수행하는 도메인 객체를 통해 업무를 위임하는 역할 수행
    DDD(Domain-Driven Design) 기반의 아키텍처에서는 비즈니스 로직에 도메인 포함 or 별도로 도메인 계층
  * 데이터 접근 계층
    데이터베이스에 접근하는 일련의 작업 수행

  레이어드 아키텍처 기반 설계 특징
  * 각 레이어는 가장 가까운 하위 레이어의 의존성을 주입받음
  * 각 레이어는 관심사에 따라 묶여 있음, 다른 레이어의 역할 침범X
  * 각 레이어가 독립적으로 작성되면 다른 레이어와의 의존성 낮춰 단위 테스트 용이

  스프링의 레이어드 아키텍처
  * View, Controller - 프레젠테이션 계층
  * Model - 비즈니스 계층, 데이터 접근 계층
    * 비즈니스 계층에 서비스를 배치해 엔티티와 같은 도메인 객체의 비즈니스 로직을 조합하도록 함
    * 데이터 접근 계층에는 DAO(Spring Data JPA에서는 Repository)를 배치해 도메인 관리

  * 프레젠테이션 계층
    상황에 따라 유저 인터페이스(UI) 계층이라고도 함
    클라이언트와의 접점
    클라이언트로부터 데이터와 함께 요청 받고, 처리 결과를 응답으로 전달
  * 비즈니스 계층
    상황에 따라 서비스 계층이라고도 함
    핵심 비즈니스 로직 구현
    트랜잭션 처리나 유효성 검사 등의 작업 수행
  * 데이터 접근 계층
    상황에 따라 영속(Persistence) 계층이라고도 함
    데이터베이스에 접근해야 하는 작업 수행

2.4 디자인 패턴
2.4.1 디자인 패턴 종류
  Gof 디자인 패턴
  1. 생성(Creational) 패턴
    객체 생성에 사용되는 패턴. 객체를 수정해도 호출부 영향X
  2. 구조(Structural) 패턴
    객체를 조합해 더 큰 구조를 만드는 패턴
  3. 행위(Behavioral) 패턴
    객체 간 알고리즘이나 책임 분배에 관한 패턴
    객체 하나로는 수행할 수 없는 작업을 여러 객체를 이용해 작업 분배. 결합도 최소화 고려 필요

2.4.2 생성 패턴
  * Abstract Factory: 구체적인 클래스 지정X, 상황에 맞는 객체 생성을 위한 인터페이스를 제공하는 패턴
  * Builder: 객체 생성과 표현을 분리해 객체를 생성하는 패턴
  * Factory Method: 객체 생성을 서브클래스로 분리해 위임하는 패턴
  * Prototype: 원본 객체 복사해 객체를 생성하는 패턴
  * Singleton: 한 클래스마다 인스턴스를 하나만 생성해 인스턴스가 하나임을 보장, 어느 곳에서도 접근 가능하게 제공하는 패턴

2.4.3 구조 패턴
  * Adapter: 클래스의 인터페이스를 의도하는 인터페이스로 변환하는 패턴
  * Bridge: 추상화와 구현을 분리해 각각 독립적으로 변형케 하는 패턴
  * Composite: 여러 객체로 구성된 복합 객체와 단일 객체를 클라이언트에서 구별 없이 다루는 패턴
  * Decorator: 객체의 결합을 통해 기능을 동적으로 유연하게 확장할 수 있게 하는 패턴
  * Facade: 서브시스템의 인터페이스 집합들에 하나의 통합된 인터페이스를 제공하는 패턴
  * Flyweight: 특정 클래스의 인스턴스 한 개를 가지고 여러 개의 '가상 인스턴스'를 제공할 때 사용하는 패턴
  * Proxy: 특정 객체 직접 참조X, 해당 객체를 대행하는 객체를 통해 접근하는 패턴

2.4.4 행위 패턴
  * Chain of Responsibility: 요청 처리 객체를 집합으로 만들어 결합을 느슨하게 만드는 패턴
  * Command: 실행될 기능을 캡슐화하여 주어진 여러 기능을 실행하도록 클래스를 설계하는 패턴
  * Interpreter: 주어진 언어의 문법을 위한 표현 수단 정의, 해당 언어로 구성된 문장 해석 패턴
  * Iterator: 내부 구조를 노출하지 않으면서 해당 객체의 집합 원소에 순차적 접근 방법 제공 패턴
  * Mediator: 한 집합에 속한 객체들의 상호작용을 캡슐화하는 객체를 정의한 패턴
  * Memento: 객체 상태 정보 저장, 필요에 따라 상태 복원 패턴
  * Observer: 객체 상태 변화를 관찰하는 관찰자들. 옵저버 목록을 객체에 등록해 상태가 변할 때마다 메서드 등을 통해 객체가 직접 옵저버에게 통지하게 하는 패턴
  * State: 상태에 따라 객체가 행동을 변경하게 하는 패턴
  * Strategy: 행동을 클래스로 캡슐화해서 동적으로 행동을 바꿀 수 있게 하는 패턴
  * Template Method: 일정 작업을 처리하는 부분을 서브클래스로 캡슐화해 전체 수행 구조는 바꾸지X, 특정 단계만 변경해 수행하는 패턴
  * Visitor: 실제 로직을 갖고 있는 객체(visitor)가 로직을 적용할 객체(element)를 방문해 실행하는 패턴

2.5 REST API
  대중적으로 가장 많이 사용되는 애플리케이션 인터페이스
  이 인터페이스를 통해 클라이언트는 서버에 접근, 자원 조작

2.5.1 REST란?
  Representational State Transfer
  분산 하이퍼미디어 시스템 아키텍처의 한 형식
  주고받는 자원에 이름을 규정하고 URI에 명시해 HTTP 메서드(GET, POST, PUT, DELETE)를 통해 해당 자원의 상태를 주고받는 것

2.5.2 REST API란?
  API: Application Programmin Interface
  애플리케이션에서 제공하는 인터페이스
  API를 통해 서버 또는 프로그램 사이를 연결
  
  REST API: REST 아키텍처를 따르는 시스템/애플리케이션 인터페이스
  REST 아키텍처를 구현하는 웹 서비스 -> RESTful하다

2.5.3 REST 특징
  * 유니폼 인터페이스
    = 일관된 인터페이스
    REST 서버는 HTTP 표준 전송 규약을 따르기에 타 언어, 플랫폼, 기술 등 호환해 사용 가능. 종속X
  * 무상태성
    서버에 상태 정보를 따로 보관, 관리X
    서버는 클라이언트가 보낸 요청에 대해 세션이나 쿠키 정보 별도 보관X
  * 캐시 가능성
    REST는 HTTP 표준을 그대로 사용 -> HTTP 캐싱 기능 적용
    서버의 트랜잭션 부하 감소, 효율적, 사용자 입장 성능 개선
  * 레이어 시스템
    REST 서버는 네트워크 상의 여러 계층으로 구성
  * 클라이언트-서버 아키텍처
    REST 서버는 API를 제공, 클라이언트는 사용자 정보를 관리하는 구조로 분리해 설계 -> 서로에 대한 의존성 낮춤

2.5.4 REST의 URI 설계 규칙
  * URL 규칙
    - URI 마지막에 '/' 포함X
    - 언더바 사용X, 하이픈 사용
    - URL에는 행위(동사)가 아닌 결과(명사) 포함
      행위는 HTTP 메서드로 표현
    - URI는 소문자로 작성
    - 파일 확장자는 URI에 포함X
    